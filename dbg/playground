#!/usr/bin/env zsh

'builtin' 'emulate' '-L' 'zsh' '-o' 'no_aliases' '-o' 'err_return' || 'builtin' 'exit'
setopt no_unset extended_glob typeset_silent no_multi_byte \
       prompt_percent no_prompt_subst warn_create_global pipe_fail

() {

if [[ ${ZSH_VERSION-} != (5.<8->*|<6->.*) ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: zsh >= 5.8 is required to execute this script"
  return 1
fi

local -r root_dir=${ZSH_SCRIPT:a:h:h}

zmodload zsh/zutil zsh/system zsh/zselect

local -a help privileged isolation
zparseopts -D -K -F -- {h,-help}=help {p,-privileged}=privileged {I,-isolation}:=isolation

if (( $#help )); then
  print -r -- "usage: ${ZSH_SCRIPT:t} [OPTION].. CONFIG"
  print -r --
  print -r -- 'OPTIONS'
  print -r -- '  -h,--help'
  print -r -- '  -p,--privileged'
  print -r -- '  -I,--isolation <docker|user> [default=docker]'
  return
fi

if [[ $#isolation -ne 0 && $isolation[2] != (docker|user) ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: invalid value of --isolation: ${(q-)isolation[2]}"
  return 1
fi

if (( ARGC != 1 )); then
  print -ru2 -- "${ZSH_SCRIPT:t}: exactly one positional argument is required"
  return 1
fi

local -r cfg=$1

if [[ -z $cfg ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: config name cannot be empty"
  return 1
fi

if [[ ! -e $root_dir/configs/$cfg ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: directory does not exist: $root_dir/configs/$cfg"
  return 1
fi

if [[ ${isolation[2]-} == user ]]; then
  if (( EUID )); then
    print -ru2 -- "${ZSH_SCRIPT:t}: you must be root for --isolation user; try with sudo"
    return 1
  fi
  print -r -- "==> setting up zsh-bench-user with $cfg ..."
  local -a create_repo
  [[ -v commands[git] ]] && create_repo=('~/zsh-bench/internal/create-repo ~/repo' 'cd ~/repo')
  exec -- $root_dir/internal/install-config $#privileged $cfg $create_repo 'exec zsh -l'
  return
fi

() {
  local cmd
  for cmd in docker tar; do
    if [[ ! -v commands[$cmd] ]]; then
      print -ru2 -- "${ZSH_SCRIPT:t}: command not found: ${(q-)cmd}"
      return 1
    fi
  done
}

if [[ ! -t 0 ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: stdin must be TTY"
  return 1
fi

local -r img=ubuntu:impish
local -r docker_run=(command docker run -i --rm ${privileged:+--privileged} --init -- $img)

if ! $docker_run sh -c true; then
  print -ru2 -- "${ZSH_SCRIPT:t}: cannot run docker; try with sudo?"
  return 1
fi

local self
self=${"$(cd -q -- $root_dir && command tar -cz -- ^.git && print -n x)"[1,-2]}

local setup=(
  'mkdir ~/zsh-bench'
  'cd ~/zsh-bench'
  'head -c '$#self' | tar -xzm'
  'cd /'
  '( ( cat <&3 >/dev/null || true; /bin/kill -TERM -- -$$; ) & ) 3<&0'
  '~/zsh-bench/internal/install-deps command-not-found >&2'
  'zsh="$(which zsh)"'
  'chsh -s "$zsh"'
  'cpuset="$(cat /proc/1/cpuset)"'
  '[ -n "$cpuset" ]'
  'printf "%s\\n" "$cpuset"'
  'cat >/dev/null')

local login=(
  'exec'
  '~/zsh-bench/internal/install-config'
  $#privileged
  ${(qqq)cfg}
  '"~/zsh-bench/internal/create-repo ~/repo"'
  '"cd ~/repo"'
  '"exec zsh -l"')

local tty
exec {tty}<&0

{
  exec {tty}<&-
  print -r -- $sysparams[pid]
  print -rn -- $self
  trap 'exit 0' TERM PIPE
  while true; do
    zselect -t 360000 || true
    print 2>/dev/null || exit 0
  done
} | {
  exec {tty}<&-
  local pid
  IFS= read -r pid
  print -r -- $pid
  $docker_run sh -uec ${(j: && :)setup}
} | {
  local pid
  IFS= read -r pid
  local cpuset
  IFS= read -r cpuset
  exec 0<&$tty {tty}<&-
  if [[ $cpuset != /docker/[[:xdigit:]]## ]]; then
    print -ru2 -- "${ZSH_SCRIPT:t}: unexpected content of /proc/1/cpuset in the docker container"
    kill -- $pid 2>/dev/null
    return 1
  fi
  local ret
  command docker exec -e TERM -e COLORTERM -it -- ${cpuset:t} sh -c ${(j: :)login} || ret=$?
  kill -- $pid 2>/dev/null || true
  return ret
}

} "$@"
