#!/usr/bin/env zsh

emulate -L zsh -o err_return
setopt no_unset typeset_silent no_multi_byte warn_create_global pipe_fail

() {

zmodload zsh/zutil

local -x LC_ALL=C

local -a help scratch_dir timestamp
zparseopts -D -K -F --          \
  {h,-help}=help                \
  {d,-scratch-dir}:=scratch_dir \
  {T,-timestamp}:=timestamp

if (( $#help )); then
  print -r -- "usage: ${ZSH_SCRIPT:t} [OPTION].."
  print -r --
  print -r -- 'OPTIONS'
  print -r -- '  -h,--help'
  print -r -- '  -d,--scratch-dir <directory>'
  print -r -- '  -T,--timestamp <milliseconds>'
  return
fi

if (( ARGC )); then
  print -ru2 -- "${ZSH_SCRIPT:t}: unexpected positional argument(s)"
  return 1
fi

if (( ! $#scratch_dir )); then
  print -ru2 -- "${ZSH_SCRIPT:t}: missing required flag: --scratch-dir"
  return 1
fi
if [[ ! -e $scratch_dir[2] ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: directory does not exist: ${(q-)scratch_dir[2]}"
  return 1
fi
if (( ! $#timestamp )); then
  print -ru2 -- "${ZSH_SCRIPT:t}: missing required flag: --timestamp"
  return 1
fi
if [[ $timestamp[2] != <->.[0-9][0-9][0-9] ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: invalid timestamp format: ${(q-)timestamp[2]}"
  return 1
fi
if [[ ! -t 0 || ! -t 1 || ! -t 2 ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: all standard file descriptors must be TTY"
  return 1
fi
if [[ ! -v commands[stty] ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: command not found: stty"
  return 1
fi
if [[ ! -v commands[reset] ]]; then
  print -ru2 -- "${ZSH_SCRIPT:t}: command not found: reset"
  return 1
fi

unset _zb_stty
typeset -g _zb_stty
_zb_stty=$(command stty -g)

function cleanup() {
  local key
  while true; do
    [[ -t 2 ]] || read -t0 -k key || break
  done 2>/dev/null
  command reset
  command stty $_zb_stty
  [[ $1 == EXIT ]] && exit
  exit $((127 + ${signals[(Ie)$1]}))
}

local sig trapped=(${${(A)=:-INT TERM HUP EXIT}:*signals})
for sig in $trapped; do
  trap "trap - $trapped; cleanup $sig" $sig
done
unset sig trapped

local -F t
local -i n stage
local data timing dt dn REPLY
data=${${"$(<$scratch_dir[2]/out; print -n x)"%x}#*$'\n'}
timing=($(<$scratch_dir[2]/timing))

if (( $#timing % 2 != 0 )); then
  print -ru2 -- "${ZSH_SCRIPT:t}: malformed timing file"
  return 1
fi
if (( $#timing == 0 )); then
  print -ru2 -- "${ZSH_SCRIPT:t}: empty timing file"
  return 1
fi

local -r clear=${(pl:$LINES::\n:):-}$'\e[H'

print -rn -- $clear
print -r -- '1. Press ENTER to see the TTY content right before T='$timestamp[2]'ms.'
print -r -- '2. Press ENTER again to see the TTY content right after T='$timestamp[2]'ms.'
print -r -- '3. Press ENTER for the third time to exit.'

IFS= read -rs
print -rn -- $clear

for dt dn in $timing; do
  if [[ $dt != <->(|.<->) || $dn != <1-> ]]; then
    print -ru2 -- "${ZSH_SCRIPT:t}: malformed timing file"
    return 1
  fi
  if (( $#data < n + dn )); then
    print -ru2 -- "${ZSH_SCRIPT:t}: malformed timing or data file"
    return 1
  fi
  (( t += dt, 1 ))
  if (( stage == 0 && 1e3 * t > timestamp[2] - 0.002 )); then
    IFS= read -rs
    stage=1
  fi
  if (( 1e3 * t >= timestamp[2] + 0.002 )); then
    IFS= read -rs
    stage=2
    break
  fi
  print -rn -- $data[n+1,n+dn]
  (( n += dn ))
done

if (( stage != 2 )); then
  print -ru2 -- "${ZSH_SCRIPT:t}: timestamp out of range"
  return 1
fi

} "$@"
